""" Define a class for implementing a biologically plausible, online, winner-
take-all algorithm for fitting a mixture of regression models to a dataset.
"""

import numpy as np

from typing import Union, Optional, Sequence


class BioWTARegressor(object):
    """ A class implementing a biologically plausible winner-take-all algorithm
    that performs a multi-modal regression in a streaming setting.

    Specifically, this learns a set of regressions, with coefficients `w[k, :]`,
    such that we have
        y[t] = sum_k z[t][k] * np.dot(w[k, :], x[t]) ,
    where `z[t]` is a one-hot encoding of the model that should be used at time
    `t` (`z[t][k] == 1` if model `k` is used), `y[t]` is the output, and `x[t]`
    is the input, or predictor, variable.

    This class attempts to fit both the coefficients `w[k, i]` and the state
    assignments `z[t]`, and do so on-the-fly, as the data is being processed.
    Moreover, it uses an implementation that has a simple interpretation in
    terms of a rate-based biologically plausible neural network.

    Attributes
    ==========
    n_models : int
        Number of models in mixture.
    n_features : int
        Number of predictor variables (features).
    rate_weights : float
        Learning rate for the regression weights.
    weights_ : array, shape `(n_models, n_features)`
        Regression weights for each of the models.
    """

    def __init__(
        self,
        n_models: int,
        n_features: int,
        rate_weights: float = 1e-3,
        rng: Union[int, np.random.RandomState, np.random.Generator] = 0,
        weights: Optional[Sequence] = None,
    ):
        """ Initialize the regression model.

        Parameters
        ----------
        n_models
            Number of models in mixture.
        n_features
            Number of predictor variables (features).
        rate_weights
            Learning rate for the regression weights.
        rng
            Random number generator or seed to use for generating initial weight
            values. If seed, a random number generator is created using
            `np.random.default_rng`. If not provided, a seed of 0 is used.
        weights
            Initial value for the weights. This overrides `rng`.
        """
        self.n_models = n_models
        self.n_features = n_features
        self.rate_weights = rate_weights

        # handle integer seeds
        if isinstance(rng, int):
            rng = np.random.default_rng(rng)

        if weights is None:
            # use random initial weights
            self.weights_ = rng.normal(size=(self.n_models, self.n_features))
        else:
            self.weights_ = np.copy(weights)

    def fit_infer(self, X: Sequence, y: Sequence) -> np.ndarray:
        """ Feed a set of samples through the model, inferring which model fits best at
        each time step, and updating the model weights.

        Parameters
        ----------
        X
            The values of the predictor variables. Shape `(n_samples, n_features)`.
        y
            The values of the dependent variable. Shape `(n_samples,)`.

        Returns an array `r` with shape `(n_samples, n_models)` such that `r[t, k]`
        shows, roughly, how likely it is that the sample at time `t` was generated by
        model `k`. Note that this is not a full probabilistic model, so this should not
        be taken literally.
        """
        n_samples, n_features = np.shape(X)
        if n_features != self.n_features:
            raise ValueError("Number of columns in X should be equal to n_features.")

        r = np.zeros((n_samples, self.n_models))
        for i, (crt_x, crt_y) in enumerate(zip(X, y)):
            crt_eps = crt_y - np.dot(self.weights_, crt_x)

            # find best-fitting model
            crt_obj = -0.5 * crt_eps ** 2
            max_obj = np.max(crt_obj)
            r0 = np.exp(crt_obj - max_obj)
            r[i] = r0 / np.sum(r0)

            k = r0.argmax()

            dw = (self.rate_weights * crt_eps[k]) * crt_x
            self.weights_[k] += dw

        return r
